- 베르의 언리얼 4 강좌(프로그래밍)
    1.  C++클래스 생성
        - 언리얼 4 문서 → 프로그래밍 가이드
            1. 프로그래밍 퀵스타트
            2. UE4 C++ 프로그래밍 입문
            3. 게임플레이 가이드에 있는 문서들
        - 블루프린트와 C++를 혼용하자
        - 프로젝트를 생성할 때 블루프린트로 제작하면 C++ class를 생성할 수 없음
        - 콘텐츠 브라우저 우클릭→ c++ 클래스 생성 →  부모 클래스 선택(Actor)→헤더파일과 cpp 파일이 생성
        - 생성자, BeginPlay(), Tick()이 이미 작성되어있음
            - 생성자는 초기화 관련
            - BeginPlay는 게임이 시작하나 처음 spawn되었을 때
            - Tick은 매 프레임 - 비활성화하고싶으면 Tick함수들을 지우고 생성자에 작성되어있는 PrimaryActorTick.bCanEverTick  = ture;를 삭제
        - 로그 남기기
            - UE_LOG(LogTemp,Log,TEXT(”출력할 문자열”));
            - 창→개발자 툴→출력 로그
        - 컴파일하기
            - 솔루션 탐색기에서 프로젝트 파일을 찾아서 Build
            - 언리얼 에디터에서 Compile버튼 누르기
    2. 변수와 Property
        - 정수, 부동소수점, 문자열, 논리 자료형, 언리얼이 제공하는 타입
        - 헤더파일에서 선언 + UPROPERTY()를 위에 넣어주기
            - 언리얼 엔진 및 에디터에 이러한 프로퍼티가 있다는 것을 알림
            - 연결되었을 때 어떻게 사용될 지 지정하기 위함
            - EditAnywhere : 아키텍처와 인스턴스 모두에서 편집 가능
            - BlueprintReadWrite : 블루프린트에서 읽고 쓰기 가능
            - BlueprintReadOnly : 블루프린트에서 읽기만 가능
            - VisibleAnywhere: 아키텍처와 인스턴스 모두에서 확인 가능
            - Transient : 해당 프로퍼티가 휘발성으로, 저장되지 않음
            - Category : 블루프린트 디테일에서 탭 나눠줌
            - UPROPERTY(EditAnywhere,BlueprintReadWrite, Category=”Damage”)
            - UPROPERTY(EditAnywhere,BlueprintReadOnly, Category=”Damage”)
            - UPROPERTY(EditAnywhere,BlueprintWriteOnly, Category=”Damage”)
        - 정수
            - short, int, long은 플랫폼마다 범위가 달라질 수  있음
            - int8, int16, int32, int64를 제공함(뒤에 붙어있는 숫자는 사용할 비트 수)
                - -128~127 / -32768 ~ 32767 / -214648648~214648647 / -9223372036854775808~9223372036854775807
            - 음수 값 안 쓸거면 uint8, uint16, uint32, uint64 사용
            - 오버플로우, 언더플로우
        - 소수
            - float, double
        - 문자열
            - FString : 저장되는 글자의 숫자에 따라 문자열의 길이가 자동으로 달라짐
                - “”가 아니라 TEXT() 매크로를 사용해야함
            - FTEXT : 현지화할 때 자주 사용
            - FName :  자주 사용되는 텍스트를 식별자로 지정해서 메모리와 CPU시간 절약
            - TCharacter : 플랫폼에 상관없이 사용 가능
        - 논리 자료형
            - bool : true / false
        - 변수의 공개 범위 - 접근 지정자
            - public, protected, private
        - 변수 값 초기화하기
            - 생성자 옆에  넣어주기AMyActor::AMyActor() : TotalDamage(200) ,DamageTimeInSeconds(1.0f) ,CharacterName(TEXT(”윤농”)) ,bAttackable(true)
            - 생성자 안에서 값 넣어주기
    3. 함수와 UFUNCTION
        
        ```cpp
        class CppClass{
        public:
        	int FunctionName(int param, int param2){
        		return 1;
        	}
        }
        ```
        
        - 이름만 보고도 무슨 함수인지 알 수 있도록 만들자
        - 헤더에서 함수를 선언해주고, cpp파일에서 정의
            
            ```cpp
            void FunctionName();
            ...
            void AMyActor::FunctionName(){
            	//동작코드
            }
            ```
            
        - 프로퍼티 관련 함수
            - 오브젝트가 초기화될 때 호출되는 함수
                - virtual void PostInitProperties() override;
                
                ```cpp
                void AMyActor::PostInitProperties(){
                	Super::PostInitProperties();
                	CalculateDPS();
                }
                ```
                
            - 오브젝트가 변경될 때 호출되는 함수
                - virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
                
                ```cpp
                void AMyActor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent){
                	CalculateDPS();
                	Super::PostEditChangeProperty(PropertyChangedEvent);
                }
                ```
                
            - 위 두 함수는 AActor에서 상속받는 함수들임
                - virtual, override함수를 같이 써줘야함
        - UFUNCTION()
            - 함수를 블루프린트에서 사용할 수 있는 등의 지정자 사용 가능
            - BlueprintCallable : 블루프린트에서 사용 가능 (개발자 → 디자이너)
            - BlueprintImplementableEvent : 기능을 디자이너가 만들기 때문에 함수의 본체를 만들 필요 없음
                - 위 지정자를 사용한 함수를 블루프린트 그래프에서 찾으면 이벤트 노드로 나옴
                - 블루프린트에서 기능을 만들지 않으면 빈 함수가 호출됨
            - BlueprintNativeEvent : 기능을 디자이너가 만들 수 있되, 만들지 않으면 C++로 구현한 함수가 사용되도록
                
                ```cpp
                UFUNCTION(BlueprintNativeEvent, Category="Damage")
                void CallFromCpp();
                virtual void CallFromCpp_Implementation();
                ...
                void AMyActor::CallFromCpp_Implementation(){
                	str.Appen(TEXT("_Implementation"));
                }
                ```
                
                - 만약 디자이너의 함수도, 프로그래머의 함수도 같이 쓰고싶다면 블루프린트에서 해당 이벤트를 생성하고 우클릭 “부모함수의 함수 호출”누르면 cpp로 만든 함수 노드가 생성
        - 콘텐츠 브라우저에서 C++ class를 우클릭하고 ‘~기반 블루프린트 클래스 생성’선택
            - UFUNCTION으로 카테고리 지정해주면 더 빨리 찾을 수 있음
    4. 튜토리얼 따라가기 : 프로그래밍 퀵스타트
        
        ```cpp
        // Sin에 따라서 위 아래로 움직이는 코드
        FVector NewLocation = GetActorLocation();
        float DeltaHeight = (FMath::Sin(RunningTIme + DeltaTime) - FMath::Sin(RunningTime));
        NewLocation.Z += DeltaHeight * 20.0f;
        RunningTime += DeltaTime;
        SetActorLocation(NewLocation);
        ```
        
        - GetActorLocation() : 현재 액터의 위치 반환
        - DeltaTime :  Tick에서 매프레임 호출될 때 얼마의 시간이 흐른 뒤에 다시 Tick함수가 호출되었는지
        - 그냥 클래스를 씬에 드래그해도 인스턴스가 생성은 되는데, 아무것도 안 넣어주었기에 보이지 않음 → blueprint를 만들어주거나  Detail에서 컴포넌트를 추가해주자.
        - FVector fvector  = FVector(3.0f,3.0f,3.0f);
    5. 로그 출력하기
        - 창 → 개발자 툴 →출력 로그
        - UE_LOG
            
            ```cpp
            UE_LOG(LogTemp,Log,TEXT("Hello World"));
            UE_LOG(LogTemp,Error,TEXT("Hello World"));
            ```
            
            - 로그 상세 수준 : 출력되는 로그의 중요도
                - Fatal : 로그로 항상 콘솔 및 로그 파일에 출력되며, 로그가 비활성화된 상태에서도 모든 작동을 중단
                - Error : 콘솔 및 로그 파일에 출력되며 빨간색으로 표시
                - Warning : 콘솔 및 로그 파일에 출력되며 로그는 노란색으로 표시
                - Display : 콘솔 및 로그 파일에 출력
                - Log : 로그 파일에는 출력되지만 게임 내의 콘솔에서는 출력되지 않음, 언리얼 에디터의 출력 로그 패널에서는 계속 출력
                - Verbose : 로그 파일에는 출력되지만 게임 내의 콘솔에서는 출력되지 않음. 일반적으로 자세한 로깅 및 디버깅에 사용
                - VeryVerbose : 로그 파일에는 출력되지만 게임 내의 콘솔에서는 출력되지 않음. 대량의 로그를 출력하는 상세한 로깅에 사용
            - 로그 카테고리 : 출력된 로그가 어떤 시스템에서 발생했는지 알려줌
                - LogTemp : 특정 카테고리에 속하지 않고, 임시로 출력
                - Log를 치고 ctrl+space로 보면 여러가지 카테고리가 있음
                - 만약 원하는 카테고리가 없다면 커스텀 카테고리를 만들어야함
                    
                    ```cpp
                    --header--
                    DECLARE_LOG_CATEGORY_EXTERN(MyLogCategory, Log, All);
                    --cpp--
                    DEFINE_LOG_CATEGORY(MyLogCategory);
                    
                    ...
                    --cpp--
                    heaader파일 include
                    ...
                    UE_LOG(MyLogCategory,Log,TEXT("My Category Log"));
                    ```
                    
                - 서식 사용하기
                    
                    ```cpp
                    FString CharacterName = TEXT("Hi");
                    UE_LOG(LogTemp,Log,TEXT("Character Name = %s"), *CharacterName);
                    
                    bool isAttackable = true;
                    UE_LOG(LogTemp,Log,TEXT("Is Attackable = %s"), isAttackable ? TEXT("true"):TEXT("false"));
                    int hp = 1;
                    UE_LOG(LogTemp,Log,TEXT("HP = %d"), hp);
                    float attackSpeed = 1.0f;
                    UE_LOG(LogTemp,Log,TEXT("attackSpeed = %f"), attackSpeed);
                    FVector CharacterPosition = GetActorLocation();
                    UE_LOG(LogTemp,Log,TEXT("Position= %s"), CharacterPosition.ToString());
                    
                    UE_LOG(LogTemp,Log,TEXT("Character Name = %s, HP = %d, Attack Speed = %f"),*CharacterName, hp, attackSpeed); 
                    ```
                    
    6. 헤더 선언하기
        - 전처리기
        - 헤더 포함할 때 위치가 중요함
            - generated.h보다 위에 선언이 되어야한다.
    7. 튜토리얼 따라가기 : 변수, 타이머, 이벤트
        - countdown클래스 만들기
            
            ```cpp
            --header--
            //#include "Components/TextRrenderComponent.h"
            #include <Engine.Classes/Components/TextRenderComponent.h>
            
            ...
            //이렇게 변수 위에 주석을 달면 에디터에서도 볼 수 있음
            UPROPERTY(EditAnywhere)
            int32 CountdownTIme;
            
            UTextRenderComponent* CountdownText;
            void UpdateTimerDisplay();
            
            void AdvaceTimer();
            void CountdownHasFinished();
            FTimerHandle CountdownTimerHandle;
            
            UFUNCTION(BlueprintNativeEvent)
            void CountdownHasFinished();
            virtual void CountdownHasFinished_Implementation();
            
            --cpp--
            void ACountdown::BeginPlay(){
            	Super::BeginPlay();
            	UpdateTimerDisplay();
            	GetWorldTimerManager().SetTimer(CountdownTimerHandle,this,&ACountdown::AdvanceTimer,1.0f,true);
            }
            
            ACountdown::ACountdown(){
            	PrimaryActorTick.bCanEverTicl = false;
            	CountdownText = CreateDefaultSubobject<UTextRenderComponent>(TEXT("Hello"));
            	CountdownText->SetHorizontalAlignment(EHTA_Center);
            	CountdownText->SetWorldSize(150.0f);
            	RootComponent = CountdownText;
            
            	CountdownTime =3;
            }
            void ACountdown::UpdateTimerDisplay(){
            	CountdownText->SetText(FString::FromInt(FMath::Max(CountdownTime,0)));
            }
            void ACountdown::AdvanceTimer(){
            	--CountdownTime;
            	UpdateTimerDisplay();
            	if(CountdownTime<1){
            		GetWorldTimerManager().ClearTimer(CountdownTimerHandle);
            		CountdownHasFinished();
            	}
            }
            void ACountdown::CountdownHasFinished_Implementation(){
            	CountdownText->SetText(TEXT("Go!"));
            }
            ```
            
        - ACountdown 블루프린트 만들기
            - CountdownHasFinished 이벤트
            - spawn Emitter at Location : Particle System 스폰하는데에 사용됨
        - Door만들기
            
            ```cpp
            --header--
            #include <Engine/Classes/Components/StaticMeshComponent.h>
            ...
            UPROPERTY(EditAnywhere)
            UStaticMeshComponen* DoorMesh;
            UPROPERTY(EditAnywhere)
            float CloseTIme;
            float DoorDeltaTime;
            bool bOpen;
            FTimerHandle DoorTImerHandle;
            FRotator OriginRotation;
            
            void Open();
            void Close();
            --cpp--
            ...
            ADoor::ADoor(){
            	PrimaryActorRick.bCanEverTick = true;
            	DoorMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Door Mesh"));
            	RootComponent = DoorMesh;
            	
            	CloseTime = 3.0f;
            }
            void ADoor::BeginPlay(){
            	Super::BeginPlay();
            	OriginRotation = GetActorRotation();
            	GetWorldTimerManager().SetTimer(DoorTImerHandle,this,&ADoor::Open,0.03f,true);
            }
            void ADoor::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            
            	DoorDeltaTime += DeltaTime;
            }
            void ADoor::Open(){
            	if(!bOpen){
            		bOpen=true;
            		DoorDeltaTime=0.0f;
            	}
            	FRotator rotation = GetActorRotation();
            	rotation = OriginRotation+ FRotator(0.0f,90.0f,DoorDeltaTime),0.0f);
            	SetActorRotation(rotation);
            	if(DoorDeltaTime > 1.0f){
            		GetWorldTimerManager().ClearTimer(DoorTimerHandle);
            		GetWorldTimerManager().SetTimer(DoorTimerHandle,this,&ADoor::Close,0.03f,true,CloseTime);
            	}
            }
            void ADoor::Close(){
            	if(bOpen){
            		bOpen=false;
            		DoorDeltaTime= 0.0f;
            	}
            	FRotator rotation = GetActorRotation();
            	rotation = OriginRotation+ FRotator(0.0f,FMath::Lerp(90.0f,0.0f,DoorDeltaTime),0.0f);
            	SetActorRotation(rotation);
            	if(DoorDeltaTime > 1.0f){
            		GetWorldTimerManager().ClearTimer(DoorTimerHandle);
            	}
            }
            ```
            
        - 이벤트를 통해 Fire 생성, 비활성화하기
            
            ```cpp
            --header--
            #include <Engine/Classes/Particles/ParticleSystemComponent.h>
            ...
            UPROPERTY(EditAnywhere)
            UParticleSystemComponent* FireParticle;
            
            UPROPERTY(EditAnywhere)
            int8 FireTime;
            FTimerHandle FireTimerHandle;
            
            void Combustion();
            UFUNTION(BlueprintCallable)
            void OffFire();
            --cpp--
            AFire::AFire(){
            	PrimaryActorTick.bCanEverTick = true;
            	FireParticle =CreateDefaultSubobject<UParticleSystemComponent>(TEXT("Fire Particle"));
            	RootComponent = FireParticle;
            
            	FireTime = 5;
            }
            void AFire::BeginPlay(){
            	Super::BeginPlay();
            	GetWorldTimerManager().SetTimer(FireTimerHandle,this,&AFire::Combustion,1.0f,true);
            }
            void AFire::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            }
            void AFire::Combustion(){
            	--FireTime;
            	if(FireTime<=0){
            		OffFire();
            	}
            }
            void OffFire(){
            	GetWorldTimerManager().ClearTimer(FireTimerHandle);
            	FireParticle->DeactivateSystem();
            }
            ```
            
            - 블루프린트로 Input받아오게 하기
                - Input E Event → OffFire
                - Blueprint의 detail패널에서 Input > AutoRecieve Input을 Player0으로 바꿈
    8. 언리얼 커스텀 구조체 만들기
        - 블루프린트에서만 사용할 구조체
            - 콘텐츠 브라우저에서 우클릭 > 블루프린트 > 구조체 생성
        - CPP에서 만든 구조체는 블루프린트에서도 사용 가능
            - 생성 과정이 조금 복잡
            - 구조체를 담을 헤더파일 만들기
                - parent 없음
                
                ```cpp
                --header--
                #include "CoreMinimal.h"
                #include "CustomStructs.generated.h"
                class UNREALSTRUCTURE_API CustomStructs{
                public:
                	CustomStructs();
                	~CustomStructs();
                };
                
                //접두사 F넣기
                USTRUCT(Atomic, BlueprintType)
                struct FCustomStruct{
                	GENERATED_USTRUCT_BODY()
                public:
                	UPROPERTY(EditAnywhere,BlueprintReadWrite)
                	AActor* actor;
                	UPROPERTY(EditAnywhere,BlueprintReadWrite)
                	int32 i;
                	UPROPERTY(EditAnywhere,BlueprintReadWrite)
                	float f;
                };
                --cpp--
                ```
                
                - atomic : 이 구조체가 항상 하나의 단위로 직렬화된다.
                - BlueprintType : 이 구조체는 블루프린트에서 사용 가능하다
            - 구조체 테스트할 액터 c++ class만들기
                
                ```cpp
                --header--
                ...
                #include "CustomStructs.h"
                ...
                UPROPERTY(EditAnywhere)
                FCustomStruct cs;
                ```
                
            - 블루프린트에서 변수를 만들고 그 type을 커스텀 구조체로 설정하기
    9. 튜토리얼 제대로 따라가기  : 게임 조종 카메라
        - 액터 배치 > 모든 클래스 > 카메라 드래그
        - 카메라 우클릭하고 pilot CameraActor → 뷰포트 조정으로 카메라 이동 가능. 빠져나올때도 pilot 중단 하면 됨
        - Camera Options의 Constraint Asepect Rotation(종횡비제한) 체크
            - 카메라의 부드러운 전환을 위함
        - 액터 클래스로 CameraDirector c++ class생성
            
            ```cpp
            --header--
            ...
            UPROPERTY(EditAnywhere)
            AActor* CameraOne;
            UPROPERTY(EditAnywhere)
            AActor* CameraTwo;
            UPROPERTY(EditAnywhere)
            float TimeToNextCameraChange;
            --cpp--
            #include <Kismet/GameplayStatics.h>
            ...
            void ACameraDirector::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            	const float TimeBetweenCameraChanges = 2.0f;
            	const float SmoothBlendTime = 0.75f;
            
            	TimeToNextCameraChange -= DeltaTime;
            	if(TimeToNextCameraChange <= 0.0f){
            		TimeToNextCameraChange += TimeBetweenCameraChanges;
            		APlayerController controller = UGameplayStatics::GetPlayerController(this, 0);
            		if(controller){
            			if((controller->GetViewTarget() != CameraOne) && (CameraOne != nullptr)){
            				controller->SetViewTarget(CameraOne);
            			}else if((controller->GetViewTarget() != CameraTwo) && (CameraTwo != nullptr)){
            				controller->SetViewTargetWithBlend(CameraTwo, SmoothBlendTime);
            			}
            		}
            	}
            }
            ```
            
        - 움직이는 액터에 카메라 붙여 크레인 샷 찍기
            - 액터 class로 MovingActor C++ class 생성
            
            ```cpp
            --header--
            ...
            float Timer;
            --cpp--
            ...
            void AMovingActor::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            
            	Timer += DeltaTime;
            
            	FVector NewLocation = GetActorLocation();
            	NewLocation.Y += FMath::Cos(Timer);
            	SetActorLocation(NewLocation);
            }
            ```
            
        - CameraOne, CameraTwo같은 별도 변수가 아니라 배열 사용해보기
            - CameraDirector
            
            ```cpp
            --header--
            ...
            UPROPERTY(EditAnywhere)
            TArray<AActor*> Cameras;
            
            int32 NowCameraIndex;
            //UPROPERTY(EditAnywhere);
            //AActor* CameraOne;
            //UPROPERTY(EditAnywhere);
            //AActor* CameraTwo;
            --cpp--
            ...
            if(TimeToNextCameraChange<=0.0f){
            	AActor* NowCamera = Cameras[NowCameraIndex];
            	TimeToNextCameraChange += TimeBetweenCameraChanges;
            	APlayerController* controller = UGameplayStatics::GetPlayerController(this, 0);
            	if(controller){
            		if((controller->GetViewTarget() != NowCamera) && (NowCamera != nullptr)){
            			controller->SetViewTarget(NowCamera);
            		}
            	}
            	NowCameraIndex++;
            	if(NowCameraIndex >=Cameras.Num()){
            		NowCameraIndex = 0;
            	}
            	...
            ```
            
        - 카메라 저장할 때 액터 포인터 대신 구조체를 사용하기
            - 구조체 만들기(CameraDirector 내부)
            
            ```cpp
            --header--
            USTRUCT(Atomic,BlueprintType)
            struct FChangeCameraData{
            	GENERATED_USTRUCT_BODY();
            public:
            	UPROPERTY(EditAnywhere,BlueprintReadWrite)
            	AActor* Camera;
            	UPROPERTY(EditAnywhere,BlueprintReadWrite)
            	float TimeBetweenCameraChanges;
            	UPROPERTY(EditAnywhere,BlueprintReadWrite)
            	float SmoothBlendTime;
            }
            ...
            UPROPERTY(EditAnywhere)
            //TArray<AActor*> Cameras;
            TArray<FChangeCameraData> Cameras;
            ...
            --cpp--
            ...
            if(TimeToNextCameraChange<=0.0f){
            	FChangeCameraData NowCamera = Cameras[NowCameraIndex];
            	TimeToNextCameraChange += NowCamera.TimeBetweenCameraChanges;
            	APlayerController* controller = UGameplayStatics::GetPlayerController(this, 0);
            	if(controller){
            		if((controller->GetViewTarget() != NowCamera.Camera) && (NowCamera.Camera != nullptr)){
            			if(NowCamera.smoothBlendTime <= 0.0f){
            				controller->SetViewTarget(NowCamera.Camera);
            			}else{
            				controller->SetViewTargetWithBlend(NowCamera.Camera,NowCamera.SmoothBlendTime);
            			}
            		}
            	}
            	NowCameraIndex++;
            	if(NowCameraIndex >=Cameras.Num()){
            		NowCameraIndex = 0;
            	}
            	...
            ```
            
    10.  튜토리얼 제대로 따라가기 : 플레이어 입력 및 폰
        - 입력을 받을 Pawn C++ 클래스 생성하기
        
        ```cpp
        --header--
        ...
        #include <Engine/Classes/Camera/CameraComponent.h>
        ...
        UPROPERTY(EditAnywhere)
        USceneComponent* OurVisibleComponent;
        
        void Move_XAxis(float AxisValue);
        void Move_YAxis(float AxisValue);
        void StartGrowing();
        void StopGrowing();
        
        FVector CurrentVelocity;
        bool bGrowing;
        
        --cpp--
        AMyPawn::AMyPawn(){
        	PrimaryActorTick.bCanEverTick = true;
        	AutoPossessPlayer= EAutoRecieveInput::Player0;
        
        	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("RootComponent"));
        	UCameraComponent* OurCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("OurCamera"));
        	OurCamera->SetupAttachment(RootComponent);
        	OurCamera->SetRelativeLocation(FVector(-250.0f,0.0f,250.0f));
        	OurCamera->SetRelativeRotation(FVector(-45.0f,0.0f,0.0f));
        
        	OurVisibleComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("OurVisibleComponent"));
        	OurVisibleComponent->SetupAttachment(RootComponent);
        }
        
        void AMyPawn::Tick(float DeltaTime){
        	Super::Tick(DeltaTime);
        	
        	float CurrentScale = OurVisibleComponent->GetComponentScale().X;
        	if(bGrowing){
        		CurrentScale+= DeltaTime;
        	}
        	else{
        		CurrentScale-=DeltaTime*0.5f;
        	}
        	CurrentScale = FMath::Clamp(CurrentScale,1.0f,2.0f);
        	OurVisibleComponent->SetWorldScale3D(FVector(CurrentScale));
        
        	if(!CurrentVelocity.IsZero()){
        		FVector NewLocation = GetActorLocation() + (CurrentVelocity * DeltaTime);
        		SetActorLocation(NewLocation);
        	}
        }
        
        //바인딩 작업
        void AMyPawn::SetupPlayerInputComponent<UInputComponent* PlayerInputComponent){
        	Super::SetupPlayerInputComponent(PlayerInputComponent);
        	PlayerInputComponent->BindAction("Grow",IE_Pressed,this,&AMyPawn::StartGrowing);
        	PlayerInputComponent->BindAction("Grow",IE_Released,this,&AMyPawn::StopGrowing);
        
        	PlayerInputComponent->BindAxis("MoveX",this,&AMyPawn::Move_XAxis);
        	PlayerInputComponent->BindAxis("MoveY",this,&AMyPawn::Move_YAxis);
        }
        
        void AMyPawn::Move_XAxis(float AxisValue){
        	//굳이 clamp를 하는 이유는 w와 위쪽 화살표를 같이 눌렀을 때 속도가 빨라질 수 있기 때문
        	CurrentVelocity.X = FMath::Clamp(AxisValue,-1.0f,1.0f) * 100.0f;
        }
        void AMyPawn::Move_YAxis(float AxisValue){
        	CurrentVelocity.Y = FMath::Clamp(AxisValue,-1.0f,1.0f) * 100.0f;
        }
        void AMyPawn::StartGrowing(){
        	bGrowing = true;
        }
        void AMyPawn::StopGrowing(){
        	bGrowing = false;
        }
        ```
        
        - USceneComponent : 위치,회전같은 Transform 정보를 갖고 있음. 충돌-렌더링 없어서 매우 가벼움
        - 액션 매핑 : 키 입력(jump, 공격 등등)
            - 프로젝트 세팅 > 엔진-입력 > 액션 매핑, 축 매핑 추가
        - 축 매핑 : 마우스 위치, 조이스틱 기울기 등등
            - 움직임이 없어도 매 프레임 값을 전달함
        - 일정 기간동안 누르고 있으면 속력이 상승되는 방향 컨트롤 구현
            
            ```cpp
            --header--
            ...
            float InputTime;
            --cpp--
            ...Tick...
            	if(!CurrentVelocity.IsZero()){
            		InputTime += DeltaTime;
            		FVector NewLocation = GetActorLocation() + (CurrentVelocity * DeltaTime*
            			(InputTime <= 1.0f ? 1.0f : 3.0f);
            		SetActorLocation(NewLocation);
            	}else{
            		InputTime = 0.0f;
            	}
            ...
            ```
            
        - 축 매핑을 누르기 시작한 직후 액션 매핑을 누르면 오브젝트를 최대 크기로 즉시 확장
            
            ```cpp
            --cpp--
            ...
            void AMyPawn::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            	
            	float CurrentScale = OurVisibleComponent->GetComponentScale().X;
            	if(bGrowing){
            		if(InputTime > 0.0f && InputTime <= 0.5f){
            			CurrentScale = 2.0f;
            		}else{
            			CurrentScale+= DeltaTime;
            		}
            	}
            	else{
            		CurrentScale-=DeltaTime*0.5f;
            	}
            	CurrentScale = FMath::Clamp(CurrentScale,1.0f,2.0f);
            	OurVisibleComponent->SetWorldScale3D(FVector(CurrentScale));
            
            	if(!CurrentVelocity.IsZero()){
            		FVector NewLocation = GetActorLocation() + (CurrentVelocity * DeltaTime);
            		SetActorLocation(NewLocation);
            	}
            }
            ...
            ```
            
    11.  튜토리얼 제대로 따라가기 - 컴포넌트와 콜리전
        - Pawn으로 C++ class인 CollidingPawn 생성
            
            ```cpp
            --header--
            ...
            UParticleSystemComponent* OurParticleSystem;
            --cpp--
            #include <Engine/Classes/Components/SphereComponent.h>
            #include <Engine/Classes/Particles/ParticleSystemComponent.h>
            #include <Engine/Classes/GameFramework/SpringArmComponent.h>
            #include <Engine/Classes/Camera/CameraComponent.h>
            
            ACollidingPawn::ACollidingPawn(){
            	PrimaryActorTick.bCanEverTick = true;	
            	USphereComponent* SphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT("RootComponent"));
            	RootComponent = SphereComponent;
            	SphereComponent->InitSphereRadius(40.0f);
            	//layer를 설정한다고 생각하자
            	SphereComponent->SetCollisionProfileName(TEXT("Pawn"));
            
            	UStaticMeshComponent* SphereVisual = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("VisualRepresentation"));
            	SphereVisual -> SetupAttachment(RootComponent);
            	static ConstructorHelpers::FObjectFinder<UStaticMesh> SphereVisualAsset(TEXT("/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere"));
            	if(SphereVisualAsset.Succeeded()){
            		SphereVisual->SetStaticMesh(SphereVisualAsset.Object);
            		SphereVisual->SetRelativeLocation(FVector(0.0f,0.0f-40.0f));
            		SphereVisual->SetWorldScale3D(FVector(0.8f));
            	}
            	OurParticleSystem = CreateDefaultSubobject<UParticleSystemComponent>(TEXT("OurParticleSystem"));
            	OurParticleSystem->SetupAttachment(RootComponent);
            	OurParticleSystem->bAutoActivate = false;
            	OurParticleSystem->SetRelativeLocation(FVector(-20.0f,0.0f,20.0f));
            	static ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT("/Game/StarterContent/Particles/P_Fire.P_Fire"));
            	if(ParticleAsset.Succeeded()){
            		OurParticleSystem->SetTemplate(ParticleAsset.Object);
            	}
            
            	USpringArmComponent* SpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraAttachmentArm"));
            	SpringArm->SetupAttachment(RootComponent);
            	SpringArm->SetRelativeRotation(FRotator(-45.0f,0.0f,0.0f));
            	SpringArm->TargetArmLengh = 400.0;
            	SpringArm->bEnableCameraLag= ture;
            	SpringARm->CameraLagSpeed = 3.0f;
            
            	UCameraComponent* Camera = CreateDefaultSubobject<UCameraComponent>(TEXT("ActualCamera"))
            	// 아래처럼 SocketName을 넣어주면 SpringArm에 있는 Socket에 카메라를 부착할 수 있음
            	Camera->SetupAttachment(SpringArm,USpringArmComponent::SocketName);
            	
            	AutoPossessPlayer = EAutoReceiveInput::Player0;
            }
            ```
            
        - 편집→프로젝트세팅→입력→액션매핑(ParticleToggle-Spacebar), 축매핑(MoveForward-W,S)(MoveRight-A,D)(Turn - 마우스 X)
        - PawnMovementComponent를 부모로 하는 C++ class생성 - CollidingPawnMovementComponent
            
            ```cpp
            --header--
            ...
            public:
            	virtual void TickComponent(float DeltaTime, enum ELevelTick TickType,FActorComponentTickFunction* ThisTickFunction) override;
            --cpp--
            void UCollidingPawnMovement::TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction){
            	Super::TickComponent(DeltaTime,TickType,ThisTickFunction);
            	// PawnOwner : 이 컴포넌트를 소유하고있는 폰
            	// UpdatedComponent : UPawnMovementComponent의 부모 클래스인 UMovementComponent에 속함, 이것을 움직이고 업데이트시켜야함
            	// ShouldSkipUpdate : 컴포넌트가 렌더가 안 되어있거나 할 때 Skip
            	if(!PawnOwner||!UpdatedComponent||ShouldSkipUpdate(DeltaTime)){
            		return;
            	}
            	//ConsumeInputVector를 통해서 input vector를 가져옴
            	//SafeMoveUpdatedComponent로 장애물을 피해 pawn을 이동시킴
            	FVector DesiredMovementThisFrame = ConsumeInputVector().GetClampedToMaxSize(1.0f)*DeltaTime*150.0f;
            	if(!DesiredMovementThisFrame.IsNearlyZero()){
            		FHitResult Hit;
            		SafeMoveUpdatedComponent(DesiredMovementThisFrame, UpdatedComponent->GetComponentRotation(),true,Hit);
            		// 충돌이 발생하면 이동을 하는 대신 표면을 타고 Sliding하도록
            		if(Hit.IsValidBlockingHit()){
            			SlideAlongSurface(DesiredMovementThisFrame,1.0f-Hit.Time, HIt.Normal,HIt);
            		}
            	}
            }
            ```
            
        - CollidingPawn
            
            ```cpp
            --header--
            ...
            virtual UPawnMovementComponent* GetMovementComponent() const override;
            
            UParticleSystemComponent* OurParticleSystem;
            // 아래 것이 에러가 뜰 때, #inlcude로 포함시키는 방법도 있지만 아래와 같이 clas를 앞에다가 두어서 임시로 class화 할 수 있다.
            class UCollidingPawnMovementComponent* OurMovementComponent;
            
            void MoveForward(float AxisValue);
            void MoveRight(float AxisValue);
            void Turn(float AxisValue);
            void ParticleToggle();
            
            --cpp--
            //위에서 임시 선언을 해주었기에 cpp에서 include를 해주어야함
            #include "CollidingPawnMovementComponent.h"
            ...생성자...
            Camera->SetupAttachment(SpringArm,USpringArmComponent::SocketName);
            OurMovementComponent = CreateDefaultSubobject<UCollidingPawnMovementComponent>(TEXT("OurMovementComponent"));
            // OurMovementComponent가 RootComponent에 따라서 Update되도록
            OurMovementComponent->UpdatedComponent = RootComponent;
            ...
            void ACollidingPawn::SetupPlayerInputComponent(UInputComponent* PalyerInputComponent){
            	Super::SetupPlayerInputComponent(PlayerInputComponent);
            	InputComponent->BindAction("ParticleToggle",IE_Pressed,this,&ACollidingPawn::ParticleToggle);
            
            	InputComponent->BindAxis("MoveForward",this,&ACollidingPawn::MoveForward);
            	InputComponent->BindAxis("MoveRight",this,&ACollidingPawn::MoveRight);
            	InputComponent->BindAxis("Turn",this,&ACollidingPawn::Turn);
            }
            
            UPawnMovementComponent* ACollidingPawn::GetMovement() const{
            	reutrn OurMovementComponent;
            }
            void ACollidingPawn::MoveForward(float AxisValue){
            	if(OurMovementComponent && (OurMovementComponent->UpdatedComponent == RootComponent)){
            		OurMovementComponent->AddInputVector(GetActorForwardVector() * AxisValue);
            	}
            }
            void ACollidingPawn::MoveRight(float AxisValue){
            	if(OurMovementComponent && (OurMovementComponent->UpdatedComponent == RootComponent)){
            		OurMovementComponent->AddInputVector(GetActorRightVector() * AxisValue);
            	}
            }
            void ACollidingPawn::Turn(float AxisValue){
            	FRotator NewRotation = GetActorRotation();
            	NewRotation.Yaw +=AxisValue;
            	SetActorRotation(NewRotation);
            }
            void ACollidingPawn::ParticleToggle(){
            	if(OurParticleSystem && OurParticleSystem->Template){
            		OurParticleSystem->ToggleActie();
            	}
            }
            ```
            
        - 자동으로 부모 중심 궤도를 도는 컴포넌트 만들기
            - SceneComponent로 RevolutionSceneComponent 생성
            
            ```cpp
            --cpp--
            URevolutionScenComponent::URevolutionSceneComponent(){
            	PrimaryComponentTick.bCanEverTick = true;
            	UStaticMeshComponent* Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("RevolutionMesh"));
            	Mesh->SetupAttachment(this);
            	Mesh->SetRelativeLocation(FVector(0.0f,100.0f,0.0f));
            	static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT("/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere"));
            	if(MeshAsset.Succeeded()){
            		Mesh->SetStaticMesh(MeshAsset.Object);
            	}
            }
            ...
            void URevolutionScenComponent::TickComponent(float DeltaTime,ELevelTick TickType,FActorComponentTickFuction* ThisTickFunction){
            	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
            	FRotator NewRotation = GetComponentRotation();
            	NewRotation.Yaw += DeltaTime * 100.0f;
            	SetWorldRotation(NewRotation);
            }
            ```
            
            - 이 컴포넌트를 추가하면 해당 오브젝트안에 공전하는 구체가 생성됨
        - 세 개의 자손을 스폰하지만, 일정 기간이 지나면 스스로 스폰 해제되는 컴포넌트 만들기
            - SceneComponent를 상속받는 SpawnSceneComponent를 생성
            
            ```cpp
            --header--
            ...
            float DestroyTimer;
            TArray<UStaticMeshComponent*> Childs;
            --cpp--
            USpawnSceneComponent::USpawnerSceneComponent(){
            	PrimaryComponentTick.bCanEverTick = true;
            	for(int i=0;i<3;i++){
            		//생성하는 오브젝트의 이름이 같으면 에러가 생기기 때문에 TEXT("Child")말고 다른 작업이 추가적으로 필요
            		UStaticMeshComponent* Child = CreateDefaultSubobject<UStaticMeshComponent>(FName(TEXT("Child"),i));
            		Child->SetupAttachment(this);
            		static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT("/Game/StarterContent/Shapes/Shape_Cone.Shape_Cone"));
            		if(MeshAsset.Succeeded()){
            			Child->SetStaticMesh(MeshAsset.Object);
            		}
            		float radian = (2.0f*PI)/3.0f;
            		radian *= i;
            		FVector Location = FVector(FMath::Cos(radian),FMath::Sin(radian),0.0f)*100.0f;
            		Child->SetRelativeLocation(Location);
            		Childs.Add(Child);
            	}
            	DestroyTimer = 3.0f;
            }
            
            void USpawnerSceneComponent::TickComponent(float DeltaTime,ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction){
            	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
            	DestroyTimer -= DeltaTime;
            	if(DestroyTimer < 0.0f){
            		for(int i=0;i<Childs.Num();i++){
            			Childs[i]->DestroyComponent();
            		}
            		DestroyComponent();
            	}
            }
            ```
            
            - CreateDefaultSubobject는 생성자에서만 가능하고, BeginPlay에서 생성하려면 새로운 방법을 써야하기에 우선 생성자에서 세 개의 자식 스폰
            - 이 컴포넌트를 액터에 추가하면 씬에 3개의 원뿔이 생성됨
            - 게임을 플레이하면 생성된 3개의 원뿔이 3초 뒤에 사라짐
        - 컴포넌트를 통해 완전한 액터를 다른 액터에 붙이는 법
            - SceneComponent로 C++ class 생성 - AttachSceneComponent
            
            ```cpp
            --header--
            ...
            UPROPERTY(EditAnywhere)
            AActor* TargetActor;
            UPROPERTY(EditAnywhere)
            AActor* ParentActor;
            --cpp--
            ...
            void UAttachSceneComponent::BeginPlay(){
            	Super::BeginPlay();
            	TargetActor->AttachToActor(ParentActor, FAttachmentTransformRules::KeepRelativeTransform);
            }
            ```
            
            - 위 컴포넌트를 추가하고 detail패널에서 TargetActor와 ParentActor를 추가
            - !Mesh를 Static에서 Movable로 바꿔야 하면 바꾸자
            - 게임을 시작하면 TargetActor가 ParentActor에 붙어서 움직이게 된다.
    
    12. 생성자에서 프로젝트에 포함된 블루프린트 클래스와 리소스 불러오기
    
    - 블루프린트에서는 노드에 있는 드롭다운 같은 것으로 불러올 수 있지만 소스코드에서는 경로를 찾아서 넣어주어야한다.
    - ConstructorHelper
        - 생성자를 초기화하는데에 도움을 준다. 프로젝트의 리소스나 클래스를 가져옴
        - 생성자에서만 사용이 가능하다.
        - PawnClass를 상속받는 BP_TestClass생성
        - Actor를 상속받는 C++ 생성 - MyActor
        
        ```cpp
        --cpp--
        AMyActor::AMyActor(){
        	PrimaryActorTick.bCanEverTick = true;
        	static ConstructorHelpers::FClassFinder<APawn>BpClass(TEXT("/Game/StarterContent/BP_TestClass"));
        	if(BpClass.Succeeded() && BpClass.Class != NULL){
        		//BPClass.Class->
        	}
        
        	UStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComponent"));
        	static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT("/Game/StarterContent/Shapes/Shape_Cone.Shape_Cone"));
        	if(MeshAsset.Succeeded() && MeshAsset.Object != NULL){
        		MeshComponent->SetStaticMesh(MeshAsset.Object);
        	}
        }
        ```
        
        - 블루프린트 클래스는 cpp에서 자신을 참조하게 할 방법이 없기에, 그것이 상속한 부모 클래스를 대신 FInd함
        - 경로의 기준은 언리얼 콘텐츠 브라우저 기준(”/Game/”)
    1. 스크립트 한글 깨짐 문제 해결하기
        - 한글로 넣어둔 주석, 값들이 전부 깨짐
        - 스크립트 파일이 유니코드가 아닌 다른 타입을 사용하고 있기 때문임
        - 비쥬얼스튜디오에서 파일을 다른이름으로 저장 → 저장 버튼 옆 드롭다운을 클릭 → 인코딩하여 저장 클릭 → 유니코드(서명 있는 UTF-8) 사용
    2. 튜토리얼 제대로 따라가기 : UMG와 유저 인터페이스
        - UMG를 사용하기 위한 모듈 종속성 구성
            - 언리얼은 여러가지 Core로 나누어져있음
                - CoreUObject / Engine / InputCore
                - UMG / SlateCore / Slate
                - Custom Module
            - 프로젝트이름.Build.cs
                
                ```cpp
                PublicDependencyModuleNames.AddRange(new string[] {"Core", "CoreUObject", "Engine", "InputCore", "UMG"});
                
                //PrivateDependencyModuleNames.AddRange(new string[] {});
                PrivateDependencyModuleNames.AddRange(new string[] {"Slate", "SlateCore"});
                ```
                
        - UI를 사용하기 위한 게임 모드 만들기
            - 프로젝트이름GameModeBase
                
                ```cpp
                --header--
                ...
                public:
                	UFUNCTION(BlueprintCallable, Category = "UMG_Game")
                	// TSubClassOf는 UCalss Type의 안정성을 보장하는 템플릿 클래스
                	// 꺽쇠 안에 있는 타입과 일치하거나 그 타입을 상속받은 타입인지 런타임에 확인하도록 도와줌
                	void ChangeMenuWidget(TSubclassOf<UUserWidget> NewWidgetClass);
                private:
                	virtual void BeginPlay() override;
                	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="UMG_Game")
                		TSubclassOf<UUserWidget> StartingWidgetClass;
                
                	UPROPERTY()
                		UUserWidget* CurrentWidget;
                --cpp--
                #include "프로젝트이름GameModeBase.h"
                #include <Blueprint/UserWidget.h>
                
                void AHowTo_UMGGameModeBase::BeginPlay(){
                	Super::BeginPlay();
                	ChangeMenuWidget(StartingWidgetClass);
                }
                void AHowTo_UMGGameModeBase::ChangeMenuWidget(TSubclassOfMUUserWidget> NewWidgetClass){
                	if(CurrentWidget != nullptr){
                		CurrentWidget->RemoveFromViewport();
                		CurrentWidget = nullptr;
                	}
                	if(NewWidgetClass != nullptr){
                		CurrentWidget = CreateWidget(GetWorld(), NewWidgetClass);
                		if(CurrendWidget != nullptr){
                			CurrentWidget->AddToViewport();
                		}
                	}
                }
                
                ```
                
            - 한번에 다수의 widget을 표시하고 상호작용이 가능하게 해줌, 당연히 한 번에 하나의 Widget만 있게 할 수도 있음
            - 하지만 Widget을 직접 제거할 필요는 없는데, 언리얼은 Garbage Collector를 통해서 자동으로 Widget을 처리해주기 때문
            - PlayerContoller를 부모로 하는 c++ UMGPlayerController를 생성
                
                ```cpp
                --header--
                --cpp--
                void AUMGPlayerController::BeginPlay(){
                	Super::BeginPlay();
                	SetInputMode(FInputModeGameAndUI());
                }
                ```
                
                - 콘텐츠 브라우저 → 유저인터페이스 → 블루프린트 위젯 → MainMenu, NewGameMenu
                - Text detail > Behaviour > Visibility(Not Hit - Testable)
                - NewGameButton detail > Event > On Clicked Event 추가 > HowTo_UMGGameModeBase 형 변환(Get Game Mode) > Change Menu Widget
                - QuitButton detail > Event > On Clicked Event 추가 > Quit Game
                - 새로운 블루프린트 클래스 생성(GameMode를 부모로) → MenuGameMode
                - 새로운 블루프린트 클래스 PlayerController → MenuPalyerController
                    - detail > Mouse Interface > Show Mouse Cursor
                - MenuGameMode detail > UMG Game > Starting Widget Class - MainMenuWidget, Default Pawn Class - Pawn, Player Controller Class - MenuPlayerController
                - 세팅 > 월드 세팅 > Game Mode > 게임모드 오버라이드 - MenuGameMode
                - MainMenuWidget에 들어가서 구성
                    - NameTextEntrh detail > player의 입력란이 적혀있지 않다면 Button이 비활성화되도록 만들어야함 > is enabled 바인딩
                        - NameTextEntry→GetText→.length→ > 0 → 반환
                    - MainMenuButton → HowTo_UMGGameModeBase에 형변환(Get GameMode) → Change Menu Widget
                    - PlayGameButton → HowTo_UMGGameModeBase에 형변환(Get GameMode) → Change Menu Widget
    3. 뷰포트에 로그 띄우기
        - 액터 블루프린트 생성 → Tick → PrintString 노드 → 실행해보면 매 프레임  로그가 출력 로그에서도, 화면에서도 출력됨
        - C++ Actor class 생성
            
            ```cpp
            --header--
            --cpp--
            void AMyActor::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            	// -1이면 한 줄 띄우고, 1이면 그 자리에 그대로 출력
            	GEngine->AddOnScreenDebugMessage(-1,2.0f, FColor::Red, TEXT("Hello 2"));
            }
            ```
            
            - 이렇게 하면 화면에는 뜨는데 로그가 출력되지 않음
            
            ```cpp
            --header--
            --cpp--
            #include <Kismet/KismetSystemLibrary.h>
            ...
            void AMyActor::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            	// 맨 앞의 WorldContextObject는 월드를 넣어주면 됨
            	UKismetSystemLibrary::PrintString(GetWorld(),TEXT("Hello 3"),true, true, FLinearColor::Green,2.0f);
            }
            ```
            
    4.  튜토리얼 제대로 따라가기 - 일인칭 슈팅 C++ 튜토리얼
        - 편집 → 프로젝트 세팅 → 맵 & 모드 → 에디터 시작 맵 변경
        - FPSProjectGameModeBase
            
            ```cpp
            --h--
            ...
            // 게임이 시작할 때 액터들의 BeginPlay를 실행시킴
            virtual void StartPlay() override;
            --cpp--
            #include "FPSProjectGameModeBase.h"
            void AFPSProjectGameModeBase::StartPlay(){
            	Super::StartPlay();
            	if(GEngine){
            		GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Yellow, TEXT("Hello World, This is FPSGameMode!"));
            	}
            }
            ```
            
        - 게임모드 설정하기
            - FPSProjectGameModeBase기반 블루프린트 생성
            - 편집→프로젝트세팅→맵&모드 → 기본 게임 모드 설정
        - 캐릭터 만들기
            - Character를 부모로하는 FPSCharacter C++ class생성
            
            ```cpp
            --header--
            ...
            UFUNCTION()
            void MoveForward(float AxisValue);
            UFUNCTION()
            void MoveRight(float AxisValue);
            
            UFUNCTION()
            void StartJump();
            UFUNCTION()
            void StopJump();
            
            --cpp--
            ...
            void AFPSCharacter::BeginPlay(){
            	Super::BeginPlay();
            	if(GEngine){
            		GEngine->AddOnScreenDebugMessage(-1,5.0f,FColor::Red, TEXT("We are using FPS"));
            	}
            }
            
            void AFPSCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent){
            	Super::SetupPlayerInputComponent(PlayerInputComponent);
            	InputComponent->BindAxis("MoveForward",this,&AFPSCharacter::MoveForward);
            	InputComponent->BindAxis("MoveRight",this,&AFPSCharacter::MoveRight);
            
            	InputComponent->BindAxis("Turn",this,&AFPSCharacter::AddControllerYawInput);
            	InputComponent->BindAxis("LookUp",this,&AFPSCharacter::AddControllerPitchInput);
            
            	InputComponent->BindAction("Jump",IE_Pressed,this,&AFPSCharacter::StartJump);
            	InputComponent->BindAction("Jump",IE_Released,this,&AFPSCharacter::StopJump);
            }
            
            void AFPSCharacter::MoveForward(float AxisValue){
            	FVector Direction = FRotationMatrix(Controller->GetControlRotation()).GetScaleAxis(EAxis::x);
            	AddMovementInput(Direction,AxisValue);
            }
            void AFPSCharacter::MoveRighr(float AxisValue){
            	FVector Direction = FRotationMatrix(Controller->GetControlRotation()).GetScaleAxis(EAxis::Y);
            	AddMovmentInput(Direction,AxisValue);
            
            void AFSPCharacter::StartJump(){
            	bPressedJump = true;
            }
            void AFSPCharacter::StopJump(){
            	bPressedJump = false;
            }
            ```
            
            - FPSCharacter기반 블루프린트 생성하기
            - 프로젝트 세팅 → 맵 & 모드 → Default Pawn Class를 BP_FPSCharacter로 설정
            - 프로젝트 세팅 → 엔진>입력 → 축 매핑 (MoveFoward-W,S),(MoveRight-A,D)
            - 프로젝트 세팅 → 엔진>입력 → 축 매핑 (Turn-MoseX),(LookUp-MouseY)
            - 프로젝트 세팅 → 엔진>입력 → 액션 매핑 (Jump-Space)
        - 스켈레탈 메쉬
            - 애셋 임포트하기
            - BP_FPSCharacter의 detail에서 스켈레탈 메쉬 적용 및 위치 조정
            - 여기서 문제점 : 메쉬의 몸통이 카메라를 가림
                - 카메라 위치를 조정하자
                - 1인칭 메쉬와 3인칭 메쉬를 따로 만들자
                
                ```cpp
                --header--
                #include <Engine/Classes/Camera/CameraComponent.h>
                ...
                UPROPERTY(VisibleAnywhere)
                UCameraComponent* FPSCameraComponent;
                
                UPROPERTY(VisibleDefaultsOnly,Category="Mesh")
                USkeletalMeshComponent* FPSMesh;
                
                --cpp--
                #include "FPSCharacter.h"
                #include <Engine/Classes/Components/CapsuleComponent.h>
                
                AFPSCharacter::AFPSCharacter(){
                	PrimaryActorTick.bCanEverTick = true;
                	FPSCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT("FirstPersonCamera"));
                	FPSCameraComponent->SetupAttachment(GetCapsuleComponent());
                	FPSCameraComponent->SetRelativeLocation(FVector(0.0f,0.0f,50.0f+BaseEyeHeight);
                	FPSCameraComponent->bUsePawnControlRotation=true;
                
                	FPSMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("FirstPersonMesh"));
                	FPSMesh->SetOnlyOwnerSee(true);
                	FPSMesh->SetupAttachment(FPSCameraComponent);
                	FPSMesh->bCastDynamicShadow = false;
                	FPSMesh->CastShadow = false;
                
                	GetMesh()->SetOwnerNoSee(true);
                }
                ```
                
                - BP_FPSCharacter에서 FPSMesh를 선택하고 1인칭용 메쉬 선택
    5. 튜토리얼 제대로 따라가기 - 일인칭 슈팅 C++ 튜토리얼 2
        - 프로젝트 세팅 → 입력 → 액션 매핑 (Fire-왼쪽 마우스 버튼)
        - actor를 부모로 하는 FPSProjectile이라는 C++클래스 생성
            
            ```cpp
            --header--
            
            #include "CoreMinimal.h"
            #include "GameFramework/Actor.h"
            #include <Engine/Classes/Components/SphereComponent.h>
            #include <Engine/Classes/GameFramework/ProjectileMovementComponent.h>
            #include "FPSProjectile.generated.h"
            ...
            UPROPERTY(VisibleDefaultsOnly, Category="Projectile")
            USphereComponent* CollisionComponent;
            UPROPERTY(VisibleAnywhere,Category="Movement")
            UProjectileMovementComponent* ProjectileMovementComponent;
            
            void FireInDirection(const FVector& ShootDirection);
            
            --cpp--
            #include "FPSProjectile.h"
            AFPSProjectile::AFPSProjectile(){
            	PrimaryActorTick.bCanEverTick = true;
            	
            	CollisionComponent = CreateDefaultsSubobject<USphereComponent>(TEXT("SphereComponent"));
            	COllisionComponent->InitSphereRadius(15.0f);
            	RootComponent = CollisionComponent;
            
            	ProjectileMovementComponent = CreateDefaultsSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
            	ProjectileMovementComponent->SetUpdatedComponenet(CollisionComponent);
            	ProjectileMovementComponent->InitialSpeed = 3000.0f;
            	ProjectileMovementComponent->MaxSpeed = 3000.0f;
            	ProjectileMovementComponent->bRotationFollowsVelocity= true;
            	ProjectileMovementComponent->bShouldBounce=true;
            	ProjectileMovementComponent->Bounciness = 0.3f;
            }
            
            ...
            void AFPSProjetile::FireInDiretion(const FVector& ShootDirection){
            	ProjectileMovementComponent->Velocity = ShootDirection*ProjectileMovementComponent->InitialSpeed;
            }
            ```
            
        - FPSCharacter
            
            ```cpp
            --header--
            #include "FPSProjectile.h"
            ...
            UFUNCTION()
            void Fire();
            UPROPERTY(EditAnywhere,BlueprintReadWrite,Category="GamePlay")
            FVector MuzzleOffset;
            UPROPERTY(EditDefaultsOnly, Category="Projectile")
            TSubclassOf<AFPSProjectile> ProjectileClass;
            --cpp--
            ...
            void AFPSCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent){
            	Super::SetupPlayerInputComponent(PlayerInputComponent);
            	InputComponent->BindAxis("MoveForward",this,&AFPSCharacter::MoveForward);
            	InputComponent->BindAxis("MoveRight",this,&AFPSCharacter::MoveRight);
            
            	InputComponent->BindAxis("Turn",this,&AFPSCharacter::AddControllerYawInput);
            	InputComponent->BindAxis("LookUp",this,&AFPSCharacter::AddControllerPitchInput);
            
            	InputComponent->BindAction("Jump",IE_Pressed,this,&AFPSCharacter::StartJump);
            	InputComponent->BindAction("Jump",IE_Released,this,&AFPSCharacter::StopJump);
            
            	InputComponent->BindAction("Fire",IE_Pressed,this,&AFPSCharacter::Fire);
            }
            ...
            void AFPSCharacter::Fire(){
            	if(ProjectileClass){
            		FVector CameraLocation;
            		FRotator CameraRotation;
            		GetActorEyesViewPoint(CameraLocation,CameraRotation);
            
            		FVector MuzzleLocation = CameraLocation + FTransform(CameraRotation).TransformVector(MuzzleOffset);
            		FRotator MuzzleRotation = CameraRotation;
            		MuzzleRotation.Pitch += 10.0f;
            	}
            	UWorld* World = GetWorld();
            	if(World){
            		FActorSpawnParameters SpawnParams;
            		SpawnParams.Owner = this;
            		SpawnParams.Instigator = GetInstigator();
            
            		AFPSProjectile* Projectile = World->SpawnActor<AFPSProjectile>(ProjectileClass,MuzzleLocation,MuzzleRotation,SpawnParams);
            		if(Projectile){
            			FVector LaunchDirection = MuzzleRotation.Vector();
            			Projectile->FireInDirection(LaunchDirection);
            		}
            	}
            }
            
            ```
            
        - FPSProjectile을 BP로 구체화
            - CollisionComponent안에 StaticMesh추가
            - StaticMesh detail에서 collision preset을 No Collision으로 함
        - BP_FPSCharacter의 클래스 디폴트 → Projectile Class를 BP_FPSProjectile로 설정
        - 문제점 : 긴 시간이 지나도 사라지지 않고, 다른 충돌체와 충돌하지 않음
            - FPSProjectile
            
            ```cpp
            --header--
            UFUNCTION()
            void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit);
            
            --cpp--
            ..생성자..
            CollisionComponent->BodyInstance.SetCollisionProfileName(TEXT("Projectile"));
            CollisionComponent->OnComponentHit.AddDynamic(this, &AFPSProjectile::OnHit);
            ...
            InitialLifeSpan = 3.0f;
            ...
            void AFPSProjectile::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalInpulse, const FHitResult& Hit){
            	if(OtherActor != this && OtherComponent->IsSimulatingPhysics()){
            		OtherComponent->AddInpulseAtLocation(ProjectileMovementComponent->Velocity* 100.0f, Hit.ImpacePoint);
            	}
            }
            ```
            
            - 편집 → 프로젝트 세팅 → 콜리젼 → object channels>새 오브젝트 채널(Projectile-Block) → Preset>새 프로파일(Projectile-Collision Enabled Query and Physics-Projectile) > pawn만 겹침, 나머지는 Block
            - 충돌체를 movable로 바꾸고 detail > physics에서 Simulate Physics enable
            - BP_FPSProjectile 에서 Collision preset을 Projectile로 바꿈
        - crosshair
            - 조준선 TGA 파일 임포트
            - HUD C++ class생성 (FPSHUD)
                
                ```cpp
                --header--
                #include "CoreMinimal.h"
                #include "GameFramework/HUD"
                #include "FPSHUD.generated.h"
                UCLASS()
                class FPSPROJECTILE_API AFSHUD:public AHUD{
                	GENERATED_BODY()
                protected:
                	UPROPERTY(EditAnywhere)
                	UTexture2D* CrosshairTexture;
                public:
                	virtual void DrawHUD() override;
                };
                --cpp--
                #include "FPSHUD.h"
                #include <Engine/Canvas.h>
                void AFPSHUD::DrawHUD(){
                	Super::DrawHUD();
                	if(CrosshairTexture){
                		FVector2D Center(Canvas->ClipX * 0.5f, Canvas->ClipY * 0.5f);
                		FVector2D CrosshairDawPosition(Center.X-(CrosshairTexture->GetSurfaceWidth() * 0.5f),Center.Y-(CrosshairTexture->GetSurfaceHeight()*0.5f));
                
                		FCanvasTileItem TileItem(CrosshairDrawPosition, CrosshairTexture->Resource, FLinearColor::White);
                		TileItem.BlendMode = SE_BLEND_Translucent;
                		Canvas->DrawItem(TileItem);
                	}
                }
                ```
                
            - FPSHUD기반 블루프린트 생성
            - 프로젝트세팅→맵&모드→HUD class를 BP_FPSHUD로 변경
    6. 필요없어진 C++ 클래스 삭제하기
        - 블루프린트는 에디터에서 간단하게 삭제 가능
        - C++ 클래스 지우기
            - 언리얼 에디터 닫기
            - visual studio에서 필요없는 cpp와 h파일 remove
            - 파일 경로 내에 있는 cpp와 h파일 제거
            - visual studio에서 빌드→솔루션 다시 빌드
    7. 캐스팅(형 변환)
        - Actor를 부모로 하는MyActor C++ class생성
            
            ```cpp
            --header--
            ...
            virtual void NotifyActorBeginOverlap(AActor* OtherActor) override;
            --cpp--
            // 매개변수를 통해 자신과 겹쳐진 Actor를 사용할 수 있게 함
            void AMyActor::NotifyActorBeginOverlap(AActor* OtherActor){
            	AProjectile* Projectile = Cast<AProjectile>(OtherActor);
            	if(Projectile != nullptr){
            		//Damage Process
            	}
            }
            ```
            
        - Actor를 부모로 하는 Projectile C++ class생성
            
            ```cpp
            --header--
            --cpp--
            ```
            
        - 블루프린트에서 형변환하기
            - ActorBeginOverlap이벤트 → Projectile에 형변환
    8. 레벨 이동 기능 만들기
        - 레벨을 두개 제작하고, PlayerStart Point를 조정
        - Actor를 부모로 하는 LevelTransferVolume C++ 클래스 생성
            
            ```cpp
            --header--
            ...
            virtual void NotifyActorBeginOverlap(AActor* OtherActor) override;
            UPROPERTY(EditAnywhere, meta = (AllowPrivateAccess="true"))
            FString TransferLevelName;
            UPROPERTY()
            class UBoxComponent* TransferVolume;
            --cpp--
            #include "LevelTransferVolume.h"
            #include "OpenLvPracCharacter.h"
            #include <Engine/Classes/Components/BoxComponent.h>
            #include <Kismet/GameplayStatics.h>
            ALevelTransferVolume::ALevelTransferVolume(){
            	PrimaryActorTick.bCanEverTick = true;
            	TransferVolume = CreateDefaultSubobject<UBoxComponent>(TEXT("TransferVolume"));
            	RootComponent = TransferVolume;
            	TransferVolume-> SetCollisionProfileName(TEXT("OverlapOnlyPawn"));
            }
            void ALevelTransferVolume::BeginPlay(){
            	Super::BeginPlay();
            }
            void ALevelTransferVolume::Tick(float DeltaTime){
            	Super::Tick(DeltaTime);
            }
            void ALevelTransferVolume::NotifyActorBeginOverlap(AActor* OtherActor){
            	AOpenLvPracCharacter* Character = Cast<AOpenLvPracCharacter>(OtherActor);
            	if(Character){
            		UGameplayStatics::OpenLevel(GetWorld(), FName(TransferLevelName));
            	}
            }
            ```
            
        - level에 LevelTransferVolume을 배치
            - detail : Transfer Level Name 수정
    9. 언리얼 열거형 UENUM
        - 구조체는 언리얼 구조체로 만들어야함
        - 열거형도 표준 열거형으로만 만들면 제한이 있음 → 언리얼 열거형
        - Actor를 상속받는 EnumTestActor를 c++로 생성
            
            ```cpp
            --header--
            #include "CoreMinimal.h"
            #include "GameFramework/Actor.h"
            #include "EnumTestActor.generated.h"
            
            UENUM(BlueprintType)
            enum class EMyColor : uint8{
            	Red UMETA(DisplayName = "Red"),
            	Green UMETA(DisplayName ="Green"),
            	Blue UMETA(DisplayName ="Blue")
            };
            UCLASS()
            class UNREALENUM_API AEnumTestActor : public AActor{
            	GENERATED_BODY()
            public:
            	AEnumTestActor();
            protected:
            	virtual void BeginPlay() override;
            public:
            	virtual void Tick(float DeltaTime)override;
            
            	UPROPERTY(EditAnywhere)
            	EMyColor MyColorTestEnum;
            }
            --cpp--
            ```
            
            - UENUM(BlueprintType)으로 지정해주었기에 우클릭을 하고 블루프린트에서도 사용 가능
            - 우클릭하고 EMyColor검색
        - Enum을 다른 곳에서도 사용하고싶다면 Struct를 만들 때처럼 부모 없이 C++ class를 만든 뒤 다른 곳에서 해당 header를 import해서 사용 가능
    10. 클릭한 위치로 캐릭터 이동시키는 기능 구현하기
        - build.cs파일은 게임 내에서 사용할 모듈을 지정 가능
            - public DependencyModuleNames에 “NavigationSystem”, “AIModule”추가
            - Box mesh를 import해서 적절하게 배치
            - Navmesh Bound Volume추가
            - 단축키 p를 누르면 이동 가능한 영역이 초록색으로 보임
            - 프로젝트세팅→입력→액션매핑(LeftClick-왼쪽 마우스 버튼)
            - PlayerController를 부모로 하는 ClickMovePlayerController를 c++로 생성
                
                ```cpp
                --header--
                #include "CoreMinimal.h"
                #include "GameFramework/PlayerController.h"
                #include "ClickMovePlayerController.generated.h"
                
                UCLASS()
                class CLICKMOVE_API AClickMovePlayerController:public APlayerController{
                	GENERATED_BODY()
                public:
                	AClickMovePlayerController();
                private:
                	bool bClickLeftMouse;
                
                	void InputLeftMouseButtonPressed();
                	void InputLeftMouseButtonReleased();
                
                	void SetNewDestination(const FVector Destination);
                	void MoveToMouseCursor();
                
                	virtual void SetupInputComponent() override;
                
                	virtual void PlayerTick(float DeltaTime) override;
                }
                -cpp--
                #include "ClickMovePlayerController.h"
                #include <Blueprint/AIBlueprintHelperLibrary.h>
                AClickMovePlayerController::AClickMovePlayerCOntroller(){
                	bShowMouseCursor = true;
                }
                void AClickMovePlayerController::SetupInputComponent(){
                	Super::SetupInputComponent();
                	InputComponent->BindAction("LeftClick",IE_Presed,this, &AClickMovePlayerController::InputLeftMouseButtonPressed);
                	InputComponent->BindAction("LeftClick",IE_Released,this, &AClickMovePlayerController::InputLeftMouseButtonReleased);
                }
                
                void AClickMovePlayerController::InputLeftMouseButtonPressed(){
                	bClickLeftMouse = true;
                }
                void AClickMovePlayerController::InputLeftMouseButtonReleased(){
                	bClickLeftMouse = false;
                }
                
                void AClickMovePlayerController::SetNewDestination(const FVector Destination){
                	APawn* const MyPawn = GetPawn();
                	if(MyPawn){
                		float const Distance = FVector::Dist(Destination,MyPawn->GetActorLocation());
                		if(Distance > 120.0f){
                			UAIBlueprintHelperLibrary::SimpleMoveToLocation(this,Destination);
                		}
                }
                
                void AClickMovePlayerController::MoveToMouseCursor(){
                	FHitResult Hit;
                	GetHitResultUnderCursor(ECC_Visibility,false,Hit);
                	if(Hit.bBlockinHit){
                		SetNewDestination(Hit.ImpactPoint);
                	}
                }
                
                void AClickMovePalyerController::PlayerTick(float DeltaTime){
                	Super::PlayerTick(DeltaTime);
                	if(bClickLeftMouse){
                		MoveToMouseCursor();
                	}
                }
                ```
                
            - character를 상속한 ClickMoveClass cc++클래스 생성
                
                ```cpp
                --header--
                ...
                UPROPERTY(VisibleAnywhere,BlurprintReadOnly, Category=Camera, meta = AllowPrivateAccess"tru");
                class UCameraComponent* CameraComponent;
                UPROPERTY(VisibleAnywhere,BlurprintReadOnly, Category=Camera, meta = AllowPrivateAccess"tru");
                class USpringArmComponent* SpringArmComponent;
                --cpp--
                #include "ClickMoveCharacter"
                #include <Engine/Classes/Components/CapsuleComponent.h>
                #include <Engine/Classes/Camera/CameraComponn
                #include <Engine/Classed/GameFramework/CharacterMovementComponent.h>\
                #include <Engine/Classes/GameFrameWork/SpringArmComponent.h>
                
                AClickMoveCharacter::AClickMoveCharacter(){
                	PrimaryActorTick.bCanEverTick = true;
                	PrimaryActorTick.bStartWithTickEnabled =true;
                
                	GetCapsuleComponent->InitCapsuleSize(42.0f,96.0f);
                	bUseControllerRotationPitch = false;
                	bUseControllerRotationYaw = false;
                	bUseControllerRotationRoll = false;
                	
                	GetCharacterMovement()->bOrientRotationToMovement = true;
                	GetCharacterMvoement()-> RotationRate = FRotator(0.0f,640.0f,0.0f);
                	GetCharacterMovement()->bConstrainToPlane = true;
                	GetCharacterMovement()->bSnapToPlaneAtStart =true;
                	
                	SpringArmComponent = CreateDefaultsSubovject<USpringArmComponent>(TEXT("CameraSpringAr"));
                	SprintArmComponent -> SetupAttachement(RootComponent);
                	SpringArmCompoenent -> SetUsingAbsoluteRotation(true);
                	SpringArmComponent->TargetArmLength = 800.0f;
                	SpringArmComponent-> SetRelativeRotation(FRotator(-60.0f,45.0f,0.0f));
                	SpringArmComponent->bDoCollisionTest = false;
                
                	CameraComponent = CreateDefaultSubobject<CameraComponent>(TEXT("Camera"));
                	CameraComponent-> SetupAttachment(SpringArmComponent, USpringArmComponent::SocketName);
                	CameraComponent->bUsePawnControlRotation=false;
                }
                
                void AClickMoveCharacter::BginPlay(){
                	Super::BeginPlay();
                }
                void AClickMoveCharacter::Tick(float DeltaTime){
                	Super::Tick(DeltaTime);
                }
                ```
                
            - ClickMoveCharacter를 기반으로 블루프린트를 만들고, 메시, 애니메이션 추가