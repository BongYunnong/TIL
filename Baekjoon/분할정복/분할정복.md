# 분할 정복

## 분할하기
- 일단 모들러 성질을 생각하지 않고 지수를 분할하는 방식을 생각
    - 5가 있으면 1+4 -> 1+(2+2) -> 1+((1+1)+(1+1))임
``` C++
long long Pow(long long x, long long m){
    if(m==0){
        return 1;
    }else if(m==1){x
        return x;
    }
    if(m%2 >0){
        return Pow(x,m-1)*x;
    }
    long long half = pow(x,m/2);
    return (half*half);
}
```
- 그 후에 모들러 성질 적용 -> %C
``` C++
long long Pow(long long x, long long m){
    if(m==0){ // 0승이니까 1
        return 1;
    }else if(m==1){ // 1승이니까 x
        return x;
    }
    if(m%2 >0){ // m이 홀수라면 지수 하나를 빼서 다음 m을 짝수로 만듦
        return Pow(x,m-1)*x;
    }
    // 짝수일 때
    long long half = pow(x,m/2);
    half%=C;
    return (half*half)%C;   // 모둘려성질
}
```
- n이 지수이고, a는 지수에 따라 곱한 중간 값. asnwer는 마지막에 다 곱해진 값 -> 나중에는 n%2가 1이 될 수밖에 없기에, answer는 마지막 값이 될 수 있음
``` C++
while(n>0){
    if(n%2==1){
        answer = answer*a;
    }
    a = a*a;
    n/=2;
}
```
- 홀수 처리 후에 나머지가 된 짝수를 처리해줌

## 지수법칙
- a^(n+m) = a^n * a^m;

## 모듈러 성질
- (a*b)%c = (a%c*b%c)%c


- 아직 모듈러 성질을 사용하는 법에 익숙하지가 않다.
    - 1629 곱셈
    - 10830 행렬제곱

## 페르마 소정리
 p가 소수이고 a가 p의 배수가 아니면, a^(p-1) = 1(mod p)이다.
 즉, a^(p-1)을 p로 나눈 나머지는 1이다.
 a^(p-1) = 1(mod P)
 a*a^(p-2) = 1(mod P)
 a^(p-2) = a^(-1)*(mod P)
 a*b^(-1)%P = A*B^(P-2)%P = (A%P)(B^(P-2)%P)%P 

 ## 피보나치 규칙
- 피보나치 규칙1
    - 피사노 주기
    - 피보나치수를 K로 나눈 나머지는 항상 주기를 갖는다.
    - 주기의 길이가 P이면, N번째 피보나치 수를 M으로 나눈 나머지는 N%P번째 피보나치수를 M으로 나눈 나머지와 같다.
    - 추가 지식 : M=10^k라면, 주기는 항상 15*10^(k-1)이다.
    - 위의 지식을 모른다 하더라도 주기를 구하는 코드를 이용해서 문제를 풀어내야한다.

- 피보나치 규칙2
    - 행렬 이용
    - [[1,1][1,0]]의 행렬과 [[F(n+1)][Fn]]을 곱하면 [[F(n+2)][F(n+1)]]이 된다.


## 아직 이해 못 한것
- 11401 이항계수3
- 11444 피보나치수6
