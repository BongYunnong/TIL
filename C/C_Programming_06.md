# C언어 기초 #6 - 배열
- 프로그래밍을 할 때, 아주 많은  변수를 사용해야 할 때가 있다.
- 예를들어 한 1000개의 변수가 필요하다면, 1000개를 다 선언하기도 힘들고, 나중에 사용하기에도 불편할 것이다.
- 이것을 더 간단하게 해주기위해 "배열"(array)라는 것이 있다.

## 배열
- 실행결과
    ``` C
    #include <stdio.h>
    int main(void){
        int num1=1;
        int num2=2;
        int num3=3;
        int numbers[3] = {1,2,3};
        int numbers_2[] = {4,5,6};
        
        printf("%d, %d, %d\n",numbers[0],numbers[1],numbers[2]);
        printf("%d, %d, %d\n",numbers_2[0],numbers_2[1],numbers_2[2]);
    }
    ```
    - 실행결과
        ```
        1, 2, 3
        4, 5, 6
        ```
- 배열은 같은 형태의 값들의 묶음이라고 보면 된다.
- 위처럼 num1,num2,num3으로 나누어서 저장해야 할 것을 numbers라는 int형 배열 변수 하나로 처리할 수 있다.
- 배열을 선언할 떄는 이렇게 선언하면 된다. 
```
'자료형' '배열이름'['배열길이'];
```
- 예시 코드는 int형에 크기가 3인 numbers라는 배열을 선언한 것이다.

- 선언과 동시에 값을 넣고싶다면 위의 예시처럼 중괄호 안에 컴마(,)로 구분해서 값을 입력해주면 된다.
- 선언할 때 배열의 길이를 지정해주지 않으면 오류가 생기지만 선언과 동시에 값을 지정해주면 값의 개수만큼 길이가 자동으로 지정된다.
- 반대로 배열의 길이는 지정했는데 데이터를 지정하지않으면 해당 배열의 값들은 모두 0으로 초기화된다.

- 주의사항
    1. 배열을 먼저 선언한 뒤 나중에 중괄호를 사용하여 일괄적으로 배열의 값을 변경하려하면 에러가 발생한다.
    2. 배열의 길이는 변수가 아닌 상수로 설정해야한다.

- 저장된 배열을 사용하고싶다면 아래의 형식을 지켜서 사용하면 된다. 
    ```
    '배열이름'['값의 index(위치)']
    ```
    - 이때 주의할 점은 index가 0부터 시작한다는 것이다. 초보 프로그래머들이 자주 실수하는 곳이니 유의하자
    - "배열의 크기가 3이니까 마지막 값을 찾기위해 numbers[3]라고 써야지" 하면 index out of range라는 오류를 보게 될 것이다. 


## 배열과 반복문
- 배열은 보통 종류가 비슷한 값을 묶어줄 때 사용하기에 값으로 반복적인 일을 수행해야 할 때가 많다. 이럴 때 반복문을 사용하면 아주 효과적이다.
``` C
#include <stdio.h>
int main(void){
   int numbers[100] = {1,2,3,4 ........ 100};
   for(int i=0;i<100;i++){
      printf("%d\n",numbers[i]);
   }
}
```
- 원래 printf함수로 100줄을 채웠어야 하지만 반복문을 통해 단 3줄로 numbers 배열에 있는 값들을 모두 출력할 수 있다.

​
## 배열의 메모리
- 그러면 이런 배열은 메모리를 얼마나 잡아먹을까?
    - 그냥 간단하게 (배열 형태의 크기* 배열의 크기)를 계산해주면 된다.
    - int numbers[3]; 이렇게 선언을 하면 값이 들어있든 들어있지 않든 (4*3)바이트를 차지한다.
    - 그렇기때문에 배열을 사용할때는 낭비되는 메모리가 없는지 생각해봐야한다.
- 그러면 배열 요소들은 어떻게 저장될까? 
    - 이것 또한 간단하다. 그냥 4바이트씩 나누어진 칸에 값이 하나씩 들어간다.
    - 그래서 &를 사용하여 배열의 주소와 배열 요소들의 주소를 확인해보면 0번째 값의 주소와 1번째 값의 주소의 차이는 4(int의 크기)라는 것을 알 수 있다. 또한 배열의 주소가 배열의 0번째 값의 주소와 같다는 것도 알 수 있다. 
- 배열 요소들의 주소를 확인할 때 &array[0], &array[1] 이렇게 확인을 했을텐데, 이것을 array+0, array+1 이렇게 더 간단하게 표현할수도 있다.
    - 여기에 재미있는 점이 있는데, array에 0을 더하면? array 자체이다. 즉, array(배열의 이름)은 배열의 시작 주소를 뜻한다.
    - 이것은 나중에 포인터를 배울때 아주 유용하니 기억해두자.



## 다차원 배열
- 그럼 이번에는 배열이 아주 많이 필요한 상황을 가정해보자. 그러면 또 배열을 1000개,10000개 만들어서 사용해야할까?
    - 아니다. 그냥 배열의 배열을 만들어주면 된다. 이런 것을 다차원 배열이라고 한다.​

- 배열은 1차원적이다. 좌표계에서 x축 하나만 있다고 생각을 하면 된다.
    - 그러면 2차원 배열은? x,y평면이다.
    - 3차원 배열은 x,y,z좌표계로 이루어진 공간 통해 표현할 수 있다.
    - (1차원 배열 : 선 , 2차원 배열 : 사각형, 3차원 배열 : 육면체)

- 2차원 배열을 선언할때는 1차원배열 뒤에 ['열 크기']만 붙여주면된다.
    ``` C
    int 2dArray[2][3];
    ```
    - 이때 2가 행의 크기, 3이 열의 크기가 되어 2dArray라는 2차원 배열에는
        ```
        [0][0]    [0][1]   [0][2]

        [1][0]    [1][1]   [1][2]
        ```
        - 이렇게 2행(가로) 3열(세로)로 정렬된 6개의 공간이 생성된다.

- 2차원 배열을 중괄호로 초기화하려면 다음과 같이 코드를 작성하면 된다.
    ```C
    int array1[2][3] = {1,2,3,4,5,6};        //[0][0] -> [0][1] -> [0][2] -> [1][0] -> [1][1] -> [1][2]순으로 값 저장

    int array2[2][3] = {{1,2,3},{4,5,6}};   //{1,2,3}이 0번째 행, {4,5,6}이 1번째 행으로 들어간다.
    ```
    - 1차원배열과 마찬가지로 데이터가 저장되지 않은 공간은 자동적으로 0으로 초기화된다.
    - 다만 주의할 점이 있는데, 초기화를 할 때 행의 크기는 설정하지 않아도 괜찮지만 열의 크기는 꼭 설정해줘야한다.
        - 그 이유는 열의 크기를 설정하면 행의 크기는 지정해주지 않아도 초기화할 값들의 개수로 행을 자동으로 정해줄 수 있는데, 반대로 행의 크기만 정해졌을 때 열의 크기를  어떻게 정해야 할 지 컴퓨터가 정할 수 없기 때문이다.

- 3차원배열은 아주 가끔 사용한다. 보통 1차, 2차원 배열정도면 데이터를 다 처리할 수 있다.



## 2차원 배열의 주소
- 1차원배열의 메모리와 주소처럼 2차원배열의 주소도 아주 중요하다.

- 1차원배열에서 배열의 이름이 배열의 시작주소와 같다고 이야기했었다. 2차원배열도 마찬가지로 배열의 이름이 2차원배열의 시작 주소이다.

- 그건 알겠는데, 2차원이다보니 array+0, array+1 이런 것은 어떻게 사용되는지 감이 잘 안 잡힌다.
    - 2차원배열 array가 있다 가정할 때, array+0은 array의 0행 배열의 시작주소를 뜻한다. array+1은 당연히 array의 1행 배열의 시작주소이다.
    - 2차원배열은 1차원배열들을 배열로 묶은 개념이다. 즉, 2차원배열의 요소 하나하나는 1차원배열(행)이라는 뜻이다.

## 주소 응용
```
*주소 == 주소에 있는 값
```
- 어떤 변수의 주소의 앞에 *를 붙이면, 그 변수의 값이 반환된다. &와 상쇄되는 문자라고 이해하면 좋다.
``` C
int num1 = 2;
```
- 이런 변수가 있을 때, &num1은 num1의 주소를 가리키는데, *&num1은 2를 가리킨다.
- 이것을 주소에 대입해볼까?

- 1차원배열에서 배열의 이름은 배열의 시작주소라고 했다.
```
int numbers[3];
```
- 이런 배열이 있으면, numbers는 &numbers[0]와 같고,
- 여기 앞에 *를 붙이면 *numbers == *&numbers[0]의 공식이 성립한다.
- 그리고 *와&는 상쇄되므로 *numbers == numbers[0]이 된다.
- *numbers가 배열의 0번째 값을 의미한다는 것이고, 이것을 다른 요소에도 대입시키면 *(numbers+i)==numbers[i]가 성립한다.


- 이제 2차원배열에 적용해보자.
``` C
int 2DArray[2][3];
```
- 이런 2차원 배열이 있을 때, 2DArray+0 == &2DArray[0]이다.
```
*(2DArray+0) == *&2DArray[0]=2DArray[0]

-> *2DArray[0]+0==2DArray[0][0]

-> **(2DArray+0)+0 == *2DArray[0]+0 == *&2DArray[0][0]
```​