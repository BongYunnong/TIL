# C언어 기초 #7 - 포인터
- C언어를 공부하는 사람들이 가장 많이 포기하는 시점이 이 포인터를 배우는 때이다. 왜냐하면 이해하기 아주 어렵기 때문이다. 덕분에 나도 처음 프로그래밍을 공부했을 때 포인터에서 막혀서 포기했었다.

- 하지만 겁먹을 필요는 없다. 이것도 여러번 보다보면 익숙해지기 마련이다.
- 포인터를 설명할 때 가장 많이 비유되는것이 택배이다. 소비자가 직접 물건을 사러 가는 것이 아니라 택배 서비스를 통해서 간접적으로 물품(값)을 받을 수 있는 것이 포인터의 기능과 매우 닮았기 때문이다.


## 포인터에 대한 간단한 설명
- 포인터는 주소를 저장하는 변수이다.
- 택배(값)를 받으려면 소비자의 주소가 있어야한다. 그것을 저장하는 것이 포인터이다.
- 주소를 저장해서 뭘 어쩌겠다는 걸까?
    - 우리가 저번에 배웠던 *연산자와 &연산자를 기억하는가? 주소값에 *를 붙이면 그 주소에 접근하여 주소의 값을 알 수 있다.
    - 즉, 포인터 변수에 저장된 주소의 값에 사용자가 접근을 할 수 있다는 것이 포인터 변수의 의의이다.

- 예제를 통해 사용법을 알아보자.
    ``` C
    #include <stdio.h>
    int main(){
        int num1=3;
        double num2 = 5;

        int* num1_p = NULL;     //num1_p에 아무것도 저장하지 않겠다.
        double* num2_p = NULL;

        num1_p = &num1;        //num1_p에 num1의 주소값을 저장하겠다.
        num2_p = &num2;

        printf("%d %d \n",num1,*num1_p);
        printf("%f %f \n",num2,*num2_p);

        return 0;
    }
    ```
    ```
    3 3
    5 5
    ```
    - 먼저 포인터를 선언할때는 [자료형]* [포인터변수 이름] = NULL; 이런 형식을 지켜서 선언해주면 된다. 
        - 여기서 NULL은 아무것도 저장하지 않겠다는 뜻이다.
        - 그리고 자료형은 포인터변수가 저장할 값의 자료형에 맞춰서 지정해주면 된다. 
    - 결과를 보면 num1과 *num1_p의 값이 같고 num2와 *num2_p의 값이 같다는 것을 알 수 있다.
    - num1_p는 num1의 주소값인 &num1를 저장하고, 여기에 *를 붙여주었으니 num1의 값인 3이 나오는 것이 당연하다.

- 다음 예제를 통해 포인터에 대해 조금 더 자세히 알아보자.
    ``` C
    #include <stdio.h>
    int main(){
        int num1=3;
        int num2 = 4;
        int* num1_p = NULL;

        num1_p = &num1;        //num1_p에 num1의 주소값을 저장하겠다.
        printf("%d %d %d \n",num1,num2,*num1_p);

        num1_p = &num2;        //num1_p에 num2의 주소값을 저장하겠다.
        printf("%d %d %d \n",num1,num2,*num1_p);

        num2 = 10;
        printf("%d %d %d \n",num1,num2,*num1_p);

        *num1_p = 50;
        printf("%d %d %d \n",num1,num2,*num1_p);

        return 0;
    }
    ```
    ```
    3 4 3
    3 4 4
    3 10 10
    3 50 50
    ```
    - 위의 예제에서 볼 수 있듯이, 포인터는 중간에 다른 변수의 주소를 저장하여 유동적으로 값에 접근할 수 있다.
    - 또한 포인터는 주소를 통해 값을 참조하는 것이기에 값이 바뀌면 포인터를 통해 접근한 값도 바뀌고, 포인터를 통해 값을 바꾸어도 그 변수에 적용이된다.
    - 어렵게 들릴수도 있겠지만 당연한 이야기이다. 값을 복사하는 것이 아니라 값의 주소를 복사한 것이기 때문이다.


- 참고로, 포인터의 크기는 32비트 시스템에서는 4바이트(32비트)이고 64비트 시스템에서는 8바이트(64비트)이다. 
    - 이것은 자료형이 무엇이든 똑같다.


## 다차원 포인터
- 포인터는 주소를 저장하는 '변수'이기 때문에 포인터변수도 자신의 주소가 있다. 그래서 다른 포인터가 또다른 포인터의 주소를 저장할 수 있다.
    - 그것을 다차원 포인터라고 말한다.

- 다차원 포인터를 선언하는 방법은 간단하다.
    - 자료형에 다차원포인터의 차원 수 만큼 *를 붙여주면 된다.
    ``` C
    int* pointer1 = NULL;   //1차원 포인터
    int** pointer2 = NULL;  //2차원 포인터(1차원포인터의 주소 저장)
    int*** pointer3 = NULL; //3차원 포인터(2차원포인터의 주소 저장)

    int num1 = 3;
    pointer1 = &num1;
    pointer2 = &pointer1;
    pointer3 = &pointer2;

    printf("%d %d %d %d \n",num1, *pointer1, **pointer2, ***pointer3);
    ```
    ```
    3 3 3 3 
    ```
    - 따지고보면 pointer2는 &(&num1)이고, pointer3는 &(&(&num1))이기 때문에, **pointer2와 ***pointer3가 num1의 값인 3을 뜻하게된다.

- 다차원 포인터라고해서 사용 메모리의 값이 증가하는 것은 아니다. 그냥 32비트면 4바이트, 64비트면 8바이트이다.

​


- 내가 처음 포인터를 배울 때 가장 의문이었던 것이 아니 어차피 값이 똑같으면 그냥 변수를 쓰면 되지, 뭐하러 포인터를 쓰냐는 것이었다.
- 아마 다른 사람들도 그럴거라 생각하는데, 이 의문은 포인터를 배열, 함수와 함께 사용하는 것을 배우면 이해할 수 있다.
- 그러니 다음에는 포인터와 배열, 함수의 관계에 대해 알아보도록하자.