# C언어 기초 #14- 동적 메모리 할당
- 프로그램을 실행할 때, 데이터를 저장하는 공간은 크게 4가지 영역으로 나뉜다.
    1. 코드 영역 : 실행 코드와 함수 저장
    2. 스택 영역 : 지역변수, 매개변수 저장 - 잠깐 동안만 사용되고 소멸됨
    3. 데이터 영역 : 전역 변수, 정적 변수 저장 - 프로그램이 종료될때까지 사용됨
    4. 힙 영역 : 동적 메모리 저장

## 동적 메모리
- 동적 메모리가 무엇이고 왜 필요한 것일까?
    - 동적 메모리는 컴파일 할 때가 아니라 프로그램이 실행될 때 실시간으로 메모리가 할당되는 것이다.
    - 동적 메모리를 왜 써야하는지는 배열과 비교해서 알아보자.

- 배열은 프로그래머가 직접 크기를 정해주고 사용한다.
    - 그런데 프로그래머가 배열의 크기가 어느정도여야 하는지 다 알수는 없을 때가 많다.
    - 그래서 그냥 무작정 크기를 크게 만들때가 있는데, 이러면 배열 메모리는 엄청 많이 할당되는데 사용하지를 않으니 메모리가 낭비된다.
    - 그렇다고 크기를 적당히 작게 만들다보면 나중에 array out of index라는 에러가 발생한다.
    - 이런 문제를 해결한답시고 배열 크기에 변수를 넣으려하지만 배열의 크기를 정할때는 상수만 가능하기에 에러가 발생한다.

- 그래서 우리는 동적으로 메모리를 할당해서 사용할 것이다.
- 아래 예시를 통해 동적 메모리를 어떻게 할당하는지 간단하게 알아보자.
    ``` C
    #include <stdio.h>
    #include <stdlib.h> //동적 메모리 할당을 위해 필요한 헤더파일
    int main(){
        int* p =NULL;
        p = (int*)malloc(4);

        if(p==NULL)
            printf("실패");
        *p = 10;
        printf("주소 : %x \n",p);
        printf("값 : %d \n",*p);

        free(p);
        p=NULL;
    }
    ```
    - 먼저 동적 메모리 할당을 위해서 stdlib.h라는 헤더파일을 include해야한다.
    - int형 포인터로 4만큼의 메모리를 할당하고, 그 포인터의 값을 10으로 바꾼다.
    - 그리고 마지막에 int형 포인터에 할당딘 메모리를 해제한다. 그리고 이제 p의 메모리가 해제되었으니 NULL을 가리키도록 만들어준다.

- calloc()
    - 위의 malloc과 비슷하게 calloc이라는 함수도 있는데, 하는 일은 똑같지만 사용 방법이 조금 다르다.
    - p = (int*)malloc(4); 이것을
    - p = (int*)calloc(1,4); 이렇게 바꾸어주면 된다.
        - 즉, 4바이트를 1개 저장할만큼의 메모리를 할당한다는 뜻이다.
        - 그러니 8바이트를 할당하고싶으면
            - p = (int*)malloc(8);
            - p = (int*)calloc(2,4);
            - 이렇게 만들어주면 된다.
    - 그리고 차이점이 하나 더 있는데, calloc을 사용하면 자동으로 동적 메모리 할당된 영역을 0으로 초기화해준다. 마치 전역변수처럼 말이다.

- realloc()
    - malloc과 calloc을 배웠지만 이것들은 메모리를 할당하면 메모리의 크기를 바꾸지 못한다는 한계가 있다.
    - 그래서 프로그래머들은 realloc()을 통해 이미 할당된 영역을 재할당해준다.
    ``` C
    #include <stdio.h>
    #include <stdlib.h> //동적 메모리 할당을 위해 필요한 헤더파일
    int main(){
        int* p =NULL;
        p = (int*)malloc(8);

        p[0] = 10;
        p[1] = 20;

        p = (int*)realloc(p,12);
        p[2] = 30;

        printf("%d %d %d\n",p[0],p[1],p[2]);

        free(p);
        p=NULL;
    }
    ```
    - 위의 예시를 보면 처음에 8바이트만큼 할당했다가 12로 재할당해서 4바이트를 추가로 사용할 수 있는 것을 알 수 있다.
    - 물론 처음에 할당했던 것 보다 적은 바이트를 할당할수도 있다. 하지만 이렇게하면 이전에 사용했던 값을 버려야 할 것이다.

## 가변인자
- 가변인자는 함수의 인자 수를 바꾸어서 호출할 수 있는 방법이다.
``` C
#include <stdio.h>

void printTotal(int num, ...)
{
    int* p = NULL;
    p = &num + 1;   // num 다음의 인자 값 주소

    if(num==1)
       printf("%d ", p[0]);
    else if(num==2)
       printf("%d ", p[0]+p[1]);
    else
       printf("%d ", p[0]+p[1]+p[2]);
}

int main()
{
    printTotal(1, 10);
    printTotal(2, 10, 20);
    printTotal(3, 10, 20, 30);

    return 0;
}
```
```
10
30
60
```
- 함수 인자에 ...라는 부분을 통해 추가적인 값을 받도록 하고,
- int형 포인터 p에 주소를 4만큼 더해 다음 인자의 값을 받아올 수 있도록 해준다.
- 덕분에 p[0]은 10, p[1]은 20, p[2]는 30이 된다.

​

​